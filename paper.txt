Realistic Daytime Skies
Tim Finer
Department of Computer Science
California State University Fullerton
tfiner@csu.fullerton.edu


1. analyzing and specifying requirements.
2. designing a software solution to the requirements specification.
3. implementing the design in computer programs.
4. testing and integrating the programs.
5. writing the required documents.
6. demonstrating the project.
7. delivering the software program and documents.
Examples of software development projects are: software development aids, user interface tools, Internet applications, and various business or scientific application programs. Some development projects may interact with a special hardware environment. Examples are: program debuggers, device drivers, network systems, code generators and linkage editors.



Development Project Report
A sample table of contents for the final report for a development project is shown below. Approval Cover Page (see Appendix G)
Abstract
Keyword List
Table of Contents (including Tables, Figures. and Appendices) 
1. Introduction
a. Description of the Problem
b. Project Objectives
c. Development Environment (software and hardware) 
d. Operational Environment (software and hardware)
2. Requirements Description (external functions and interfaces)
3. Design Description (architecture, internal functions and interfaces
4. Implementation (organization of source file structure, reference list of files) 
5. Test and Integration (plan and results)
6. Installation Instructions
7. Operating Instructions
8. Recommendations for Enhancements
9. Bibliography (citing all references used)



1. Introduction
a. Description of the Problem
Interactive realistic daytime sky.


b. Project Objectives
1. Interactive
2. Realistic model of daylight
3. Portable to OS X, Linux, Windows

The first two stated words "interactive" and "realistic" are at odds with one another.

c. Development Environment (software and hardware) 
Phase I
Hardware
  MacbookPro Early 2011 2.2 GHz i7 
  8 Gb RAM
  AMD Radeon HD 6750M 1Gb VRAM

Software
  OS: OS X 10.10.5 (Yosemite)
  Editor: Sublime Text 2
  Package System: Homebrew 0.9.5
  Build: CMake 3.0.2 
  Compiler: Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn)

About halfway through development I realized that I was spending more time on portability than I had actually making progress towards the goal of rendering a suitable daytime sky.

Phase II
Hardware
  Intel i7-4770K 3.5 GHz
  16 Gb RAM
  Nvidia Quadro K600 4 Gb RAM
  Dual monitor

Software
  OS: Windows 7
  IDE: Visual Studio 15

d. Operational Environment (software and hardware)
A windows PC that is capable of running Windows 7.
Video card with 1 Gb of VRAM 
Monitor
Mouse
Keyboard


3. Design Description
The design of the software is broken up into several modules internally.

The main application, written in C++ is broken up into four parts: 
  GLSL shader management
    loading, compiling and linking the GLSL shaders
  Cloud generation
  Rendering
    OpenGL state management, setting uniform variables, drawing commands.
  Operating system interface
    file I/O, user input, window management, OpenGL context management

See Figure 1.

The GPU is sent two GLSL programs:
1. The background sky color is rendered by this program made up of a vertex and a fragment shader.
The vertices are generated by a call gluSphere with normals pointing at the camera and front face culling so that the inside of the dome is rendered. The vertex shader computes Rayleigh and Mie scattering variables and passes them to the fragment shader, where the phase is calculated (to prevent banding).


4. Implementation (organization of source file structure, reference list of files) 



5. Test and Integration (plan and results)
This is a simulation of a very complex natural system. The stated goal of this project was interactive realism. The results are a series of comparisons to photos.


6. Installation Instructions
Unzip the file Finer-CSUF-Project-2015.zip.  The file contains a folder with a README, an executable named sky.exe and two shader files: SinglePass.glsl and SkySphere.glsl.

7. Operating Instructions
Run the Raycast.exe executable by double clicking it via windows explorer. 

Keyboard Interface
Letter  Function
T Toggle noise type between Pyroclastic and Simplex.
3 Cloud density increase (shift to decrease)
4 Cloud noise alpha increase (shift to decrease)
5 Cloud noise beta increase (shift to decrease)
6 Cloud noise octave increase (shift to decrease)
7 Cloud noise simplex persistence increase (shift to decrease)
8 Cloud noise simplex scale increase (shift to decrease)
9 Cloud noise packing increase (shift to decrease)
C Cloud noise new seed

Q Ray marching increase samples taken in cloud (shift to decrease)
D Ray marching Increase scale (shift to decrease)
H Sky Increase camera height (shift to decrease)
S Sun brightness increase (shift to decrease)
N Sky samples increase (shift to decrease)
M Sky Mie scattering variable increase (shift to decrease)
R + Ctrl  Sky Raleigh scale depth variable increase (shift to decrease)
R Sky Raleigh scattering variable increase (shift to decrease)
A Cloud absorption variable increase (shift to decrease)

Number Pad Camera Control
1 Camera field of view increase
2 Camera field of view decrease
& Camera pan up
( Camera pan down
% Camera pan left
\ Camera pan right
- Camera roll left
! Camera roll left

8. Recommendations for Enhancements

9. Bibliography (citing all references used)


Background

Whitted: Ray Tracing
What is ray tracing?

Ebert: Ray Marching
What is ray mayching, chap 12, Ebert?

"stepping front to back along each ray from the eye until either total opacity is reached or the ray hits a back clipping plane"  Ebert 349


Grasshopper:
    To make this a one-pass process and remove two texture lookups from the fragment shader, we can use a procedure like this:

    Draw a cube’s front-faces to perform the raycast.
    On the CPU, compute the eye position in object space and send it down as a uniform.
    Also on the CPU, compute a focal length based on the field-of-view that you’re using to generate your scene’s projection matrix.
    At the top of the fragment shader, perform a ray-cube intersection.
    Raycasting on front-faces instead of a full-screen quad allows you to avoid the need to test for intersection failure. Traditional raycasting shaders issue a discard if there’s no intersection with the view volume, but since we’re guaranteed to hit the viewing volume, so there’s no need.


Iquilez

Problems rendering atmospheric effects:
1. Scattering
Forward
Backward
Single
Multiple

Nishita     93: Single scattering
            96: Multiple scattering
            97: Basis functions

Preetham    99: Analytic

GPU Based
Haber       05: Twilight
GPU Gems 2  05: Simplified analytic
Bruneton    08: Shadows and shafts


Hosek       13: Improved Preetham



Method

Modeling
    sky light
        scattering
    cloud morphology
        absorption
        scattering
        shading    

Implementation
Block Diagram


Evaluation
Problems encountered:
1. Underestimated GLSL learning curve
2. Too much emphasis on portability
3. GLSL is not easy to develop in
    Documentation and examples are contradictory and sparse
    Language has undergone many changes from 1.2 to 3.2.
    Debugging support is weak

Lessons Learned
Implement new algorithms in a known environment to minimize time spent on tasks not related to the problem at hand.


My knowledge of GLSL wasn't up to the task of implementing advanced rendering algorithms.

OS X does not support backwards 

GLSL is a very unforgiving environment for research.  
1. Not well documented.
2. Very difficult to debug
3. Fairly low level
4. Knowledge of the underlying hardware is necessary
5. Many cumulative restrictions hamper experimentation (e.g. 3D texture size, time limit per frame).

I underestimated the learning curve requirement for GLSL and subsequently was not able to pursue my research to a degree that I feel is satisfactory. OpenGL's API has changed significantly several times since the adoption of GLSL as the new standard. It is difficult to find  resources that tie us modern OpenGL and modern rendering techniques like ray marching.  The reference material I did find covered subsets of the various techniques (3D textures, noise, random functions, scattering equations, multiple pass rendering, ray marching, etc.). These references were often written for a generic CPU, a Direct3D HLSL, Microsoft Windows/Linux or WebGL.  Each has 

The minimum level of knowledge required to get something meaningfully displayed  

Initially, the intention was to implement portable source code that would be developed on OS X.  However, I spent too much time on this implied feature when it was never a hard requirement to begin with.  Problems that I ran into:

GPU Gems 2

there are many disadvantages to developing modern OpenGL on OS X.
Examples:
1. Special attention to the various OpenGL wrapper libraries must be handled in order to even use OpenGL on OS X (glfw, glee, etc.).  
2. Debugging support on OS X is minimal for C++ and OpenGL.  The only possibility of debugging comes from using gdb, lldb or Xcode's debugger.  All of which have significant learning curves of their own.
3. Old and new code is not easily mixed.
4. A lot of example code and tutorials are written with Linux or Windows in mind.

Spent too much time trying to compile

If I did this project again, I would have stuck to CPU algorithms first and treated running on the GPU as an optimization instead of a platform.

What rendering algorithms will be used?
Multipass
Raymarching through a 3D Cube.

How will clouds be modeled?
As a 3D texture

How will the sky be modeled?
As a sky dome

What environment will the program operate in?
C++, GLSL

Implement algorithms using OpenGL programmable shaders.

Time of Day
Atmospheric Quality
Position on Earth (including elevation)
Cloud related variables (morphology, density, color)


Conclusion and Future Work


References
