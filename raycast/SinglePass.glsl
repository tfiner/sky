-- VS

in vec4 Position;
out vec4 vPosition;
uniform mat4 ModelviewProjection;

void main()
{
    gl_Position = ModelviewProjection * Position;
    vPosition = Position;
}

-- GS

layout(points) in;
layout(triangle_strip, max_vertices = 24) out;

in vec4 vPosition[1];

uniform mat4 ModelviewProjection;
uniform mat4 ProjectionMatrix;
uniform mat4 ViewMatrix;
uniform mat4 Modelview;

vec4 objCube[8]; // Object space coordinate of cube corner
vec4 ndcCube[8]; // Normalized device coordinate of cube corner
ivec4 faces[6];  // Vertex indices of the cube faces

void emit_vert(int vert)
{
    gl_Position = ndcCube[vert];
    EmitVertex();
}

void emit_face(int face)
{
    emit_vert(faces[face][1]); emit_vert(faces[face][0]);
    emit_vert(faces[face][3]); emit_vert(faces[face][2]);
    EndPrimitive();
}

void main()
{
    faces[0] = ivec4(0,1,3,2); faces[1] = ivec4(5,4,6,7);
    faces[2] = ivec4(4,5,0,1); faces[3] = ivec4(3,2,7,6);
    faces[4] = ivec4(0,3,4,7); faces[5] = ivec4(2,1,6,5);

    vec4 P = vPosition[0];
    vec4 I = vec4(1,0,0,0);
    vec4 J = vec4(0,1,0,0);
    vec4 K = vec4(0,0,1,0);

    objCube[0] = P+K+I+J; objCube[1] = P+K+I-J;
    objCube[2] = P+K-I-J; objCube[3] = P+K-I+J;
    objCube[4] = P-K+I+J; objCube[5] = P-K+I-J;
    objCube[6] = P-K-I-J; objCube[7] = P-K-I+J;

    // Transform the corners of the box:
    for (int vert = 0; vert < 8; vert++)
        ndcCube[vert] = ModelviewProjection * objCube[vert];

    // Emit the six faces:
    for (int face = 0; face < 6; face++)
        emit_face(face);
}

-- FS

out vec4 FragColor;

uniform sampler3D Density;
uniform vec3 LightPosition = vec3(0.25, 1.0, 3.0);
uniform vec3 LightIntensity = vec3(1.0);
uniform float Absorption = 1.0;
uniform mat4 Modelview;
uniform float FocalLength;
uniform vec2 WindowSize;
uniform vec3 RayOrigin;

// Dark orange
uniform vec3 ShadowLight = vec3(1.0, 0.757, 0.55) * 0.5;

// Orange
// uniform vec3 AmbientLight = vec3(1.0, 0.757, 0.55);
// Blue
// uniform vec3 AmbientLight  = vec3(.196, 0.557, 0.831);
uniform vec3 AmbientLight  = vec3(0.0, 0.0, 1.0);
uniform vec3 AmbientShadow = vec3(0.0, 1.0, 0.0);
uniform float AmbientScale = 0.25;

const vec3 SunColor = vec3(1.0, 0.757, 0.55);
const vec3 CloudShadow = vec3(.196, 0.557, 0.831);

uniform int numSamples = 128;
uniform int numLightSamples = 16;

const float maxDist = sqrt(3.0);
const float densityFactor = 5;

struct Ray {
    vec3 Origin;
    vec3 Dir;
};

struct AABB {
    vec3 Min;
    vec3 Max;
};

bool IntersectBox(Ray r, AABB aabb, out float t0, out float t1)
{
    vec3 invR = 1.0 / r.Dir;
    vec3 tbot = invR * (aabb.Min-r.Origin);
    vec3 ttop = invR * (aabb.Max-r.Origin);
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    vec2 t = max(tmin.xx, tmin.yz);
    t0 = max(t.x, t.y);
    t = min(tmax.xx, tmax.yz);
    t1 = min(t.x, t.y);
    return t0 <= t1;
}


float ambientSample(vec3 samplePos) {
   return texture(Density, samplePos).x /** densityFactor*/;
   // return .5;
}

// Generated by C++ code using the wonderful code from:
// http://corysimon.github.io/articles/uniformdistn-on-sphere/
const int SphereSamplesNum = 16;
const vec3 SphereSamples[] = vec3[](
   vec3(-0.410592, -0.525111, -0.745435),
   vec3(0.087347, 0.930239, -0.356408),
   vec3(- 0.129484, 0.889726, 0.437746),
   vec3(0.134125, 0.981163, -0.139031),
   vec3(0.192480, 0.235052, 0.952734),
   vec3(- 0.662847, 0.668130, -0.337989),
   vec3(- 0.962695, -0.034177, -0.268423),
   vec3(0.253577, -0.093184, -0.962816),
   vec3(0.631641, 0.770339, 0.087217),
   vec3(- 0.205043, 0.000461, -0.978753),
   vec3(0.029485, 0.976917, -0.211575),
   vec3(0.949133, -0.224809, 0.220471),
   vec3(- 0.073030, 0.164446, 0.983679),
   vec3(0.101097, 0.225632, -0.968953),
   vec3(0.162797, 0.251838, -0.953978),
   vec3(- 0.388335, -0.370831, 0.843611)
);


// Naive raycasting 
const int AmbientSamples = 8;
vec3 ambientOcclusion(vec3 samplePos, float stepSize) {
   // Ambient occlusion, brute force
   float ambientShadowIntensity = 0.0;
   float sampleScale = 1.0/SphereSamplesNum * AmbientSamples;

   float step = stepSize;
   //for(int ao = 0; ao < AmbientSamples && ambientShadowIntensity == 0.0; ++ao, step+=stepSize) {
      for(int ps = 0; ps < SphereSamplesNum && ambientShadowIntensity == 0.0; ++ps) {
         vec3 aoSamplePos = samplePos + (SphereSamples[ps] * stepSize);
         // float cloudDensity = texture(Density, aoSamplePos).x * densityFactor * Absorption;

         //if(cloudDensity >= 0)
         //   ambientShadowIntensity = 1.0;
         //ambientIntensity -=
         //   ambientSample(samplePos + SphereSamples[ps] * step) *
         //   sampleScale;
      }
   //}

   // return AmbientLight * AmbientScale;
   return mix(AmbientLight, AmbientShadow, ambientShadowIntensity);
}

float shadowAttenuation(vec3 samplePos, vec3 lightDir, float stepSize){
   vec3 shadowSamplePos = samplePos + lightDir;

   // Shadow rays
   float sampledLightIntensity = 1.0;
   for(int s = 0; s < numLightSamples; ++s) {
      float cloudDensity = texture(Density, shadowSamplePos).x * densityFactor;
      sampledLightIntensity *= 1.0 - Absorption*stepSize*cloudDensity;
      shadowSamplePos += lightDir;
   }

   return min(1.0, max(0.0, sampledLightIntensity));
}


// Returns the central difference of a value inteh cloud at samplePos given an offset.
vec3 CentralDifferenceCloud(vec3 samplePos, float offset) {
   float x0 = texture(Density, samplePos + vec3(1.0, 0.0, 0.0) *  offset).x;
   float x1 = texture(Density, samplePos + vec3(1.0, 0.0, 0.0) * -offset).x;
   float xm = (x0 - x1) / (2 * offset);
   float y0 = texture(Density, samplePos + vec3(0.0, 1.0, 0.0) *  offset).x;
   float y1 = texture(Density, samplePos + vec3(0.0, 1.0, 0.0) * -offset).x;
   float ym = (y0 - y1) / (2 * offset);
   float z0 = texture(Density, samplePos + vec3(0.0, 0.0, 1.0) *  offset).x;
   float z1 = texture(Density, samplePos + vec3(0.0, 0.0, 1.0) * -offset).x;
   float zm = (z0 - z1) / (2 * offset);
   return vec3(xm, ym, zm);
}

// Finds a normal at samplePos, dots the normal vs. the lightDir and 
// shades the cloud density like a surface.
float CentralDifferenceShading(vec3 samplePos, vec3 lightDir, float stepSize){
   vec3 normal = normalize(CentralDifferenceCloud(samplePos, stepSize));
   return dot(lightDir, normal);
}

// Blue
uniform vec3 AmbientColor  = vec3(.196, 0.557, 0.831);
vec3 Ambient(){
   return AmbientColor * AmbientScale;
}

float Lambert(vec3 lightDir, vec3 normal){
   return max(0.0, dot(lightDir, normal));
}

const vec3 DiffuseColor = vec3(1.0, 1.0, 1.0);
vec3 Diffuse(vec3 lightDir, vec3 normal) {
   return Lambert(lightDir, normal) * DiffuseColor;
}

const float Shininess = 0.0125;
const vec3 SpecularColor = vec3(1.0, 1.0, 1.0);
vec3 BlinnPhongSpecular(vec3 lightDir, vec3 normal, vec3 viewDir) {
   vec3 halfDir = normalize(lightDir + viewDir);
   float specAngle = max(0.0, dot(halfDir, normal));
   float specular = pow(specAngle, Shininess);
   return specular * SpecularColor;
}


// Render a color as thought the cloud were a traditional surface.
// Obtain a normal using the central difference of the sample.
vec3 SurfaceColor(vec3 samplePos, vec3 lightDir, float stepSize, vec3 viewDir) {
   vec3 normal = normalize(CentralDifferenceCloud(samplePos, stepSize));
   float lambert = Lambert(lightDir, normal);
   vec3 specular = vec3(0.0);
   if(lambert > 0.0)
      specular = BlinnPhongSpecular(lightDir, normal, viewDir);

   return Ambient() +
          Diffuse(lightDir, normal) +
          BlinnPhongSpecular(lightDir, normal, viewDir);
}

const float ScreenGamma = 1.8;
vec3 GammaCorrect(vec3 colorLinear) {
   return pow(colorLinear, vec3(1.0 / ScreenGamma));
}


void main()
{
    float stepSize = maxDist / float(numSamples);
    float lightScale = maxDist / float(numLightSamples);

    vec3 rayDirection;
    rayDirection.xy = 2.0 * gl_FragCoord.xy / WindowSize - 1.0;
    rayDirection.z = -FocalLength;
    rayDirection = (vec4(rayDirection, 0) * Modelview).xyz;

    Ray eye = Ray( RayOrigin, normalize(rayDirection) );
    AABB aabb = AABB(vec3(-1.0), vec3(+1.0));

    float tnear, tfar;
    IntersectBox(eye, aabb, tnear, tfar);
    if (tnear < 0.0) tnear = 0.0;

    vec3 rayStart = eye.Origin + eye.Dir * tnear;
    vec3 rayStop = eye.Origin + eye.Dir * tfar;
    rayStart = 0.5 * (rayStart + 1.0);
    rayStop = 0.5 * (rayStop + 1.0);

    vec3 samplePos = rayStart;
    vec3 viewDir = normalize(rayStop - rayStart);
    vec3 step = viewDir * stepSize;
    float travel = distance(rayStop, rayStart);
    float scaledSampleValue = 1.0;
    vec3 lightFrag = vec3(0.0);

    float samplesTaken = 0.0;
    for (int i=0; i < numSamples && travel > 0.0; ++i, samplePos += step, travel -= stepSize, ++samplesTaken) {
        float density = texture(Density, samplePos).x * densityFactor;
        if (density <= 0.0)
            continue;

        // How much light is reflected after being absorbed.
        scaledSampleValue *= 1.0-density*Absorption*stepSize;
        if (scaledSampleValue <= 0.1)
            break;

        // Attenuate for shadows.
        vec3 lightDir = normalize(LightPosition - samplePos);
        float sampledLightIntensity = shadowAttenuation(samplePos, lightDir*lightScale, stepSize);
        vec3 Li = LightIntensity * sampledLightIntensity + ShadowLight * sampledLightIntensity;
        Li += SurfaceColor(samplePos, -lightDir, stepSize, viewDir) * stepSize;
        lightFrag += Li*scaledSampleValue*density*stepSize;
    }

   FragColor.rgb = GammaCorrect(lightFrag);
   FragColor.a = 1 - scaledSampleValue;
}
